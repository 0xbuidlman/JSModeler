<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>

	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="../build/three.min.js"></script>
<!-- JSModeler includes start -->
	<script type="text/javascript" src="../../src/core/jsm.js"></script>
	<script type="text/javascript" src="../../src/core/timer.js"></script>
	<script type="text/javascript" src="../../src/core/algorithm.js"></script>
	<script type="text/javascript" src="../../src/core/async.js"></script>
	<script type="text/javascript" src="../../src/core/check.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord.js"></script>
	<script type="text/javascript" src="../../src/geometry/determinant.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/matrix.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystem.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystemutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sector.js"></script>
	<script type="text/javascript" src="../../src/geometry/sectorutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/line.js"></script>
	<script type="text/javascript" src="../../src/geometry/lineutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/box.js"></script>
	<script type="text/javascript" src="../../src/geometry/boxutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sphere.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformation.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformationutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/plane.js"></script>
	<script type="text/javascript" src="../../src/geometry/planeutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/projection.js"></script>
	<script type="text/javascript" src="../../src/geometry/convexhull.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygonutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/octree.js"></script>
	<script type="text/javascript" src="../../src/geometry/bsptree.js"></script>
	<script type="text/javascript" src="../../src/geometry/utilities.js"></script>
	<script type="text/javascript" src="../../src/geometry/ray.js"></script>
	<script type="text/javascript" src="../../src/modeler/body.js"></script>
	<script type="text/javascript" src="../../src/modeler/model.js"></script>
	<script type="text/javascript" src="../../src/modeler/color.js"></script>
	<script type="text/javascript" src="../../src/modeler/light.js"></script>
	<script type="text/javascript" src="../../src/modeler/material.js"></script>
	<script type="text/javascript" src="../../src/modeler/adjacencylist.js"></script>
	<script type="text/javascript" src="../../src/modeler/bodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/textureutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/cututils.js"></script>
	<script type="text/javascript" src="../../src/modeler/generator.js"></script>
	<script type="text/javascript" src="../../src/modeler/camera.js"></script>
	<script type="text/javascript" src="../../src/modeler/explode.js"></script>
	<script type="text/javascript" src="../../src/modeler/exporter.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebody.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglemodel.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/converter.js"></script>
	<script type="text/javascript" src="../../src/modeler/rayutils.js"></script>
	<script type="text/javascript" src="../../src/import/binaryreader.js"></script>
	<script type="text/javascript" src="../../src/import/importer.js"></script>
	<script type="text/javascript" src="../../src/import/importer3ds.js"></script>
	<script type="text/javascript" src="../../src/import/importerobj.js"></script>
	<script type="text/javascript" src="../../src/import/importerstl.js"></script>
	<script type="text/javascript" src="../../src/import/importercommon.js"></script>
	<script type="text/javascript" src="../../src/extras/solidgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/extgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/painter.js"></script>
	<script type="text/javascript" src="../../src/extras/drawing.js"></script>
	<script type="text/javascript" src="../../src/extras/subdivision.js"></script>
	<script type="text/javascript" src="../../src/extras/svgtomodel.js"></script>
	<script type="text/javascript" src="../../src/extras/csg.js"></script>
	<script type="text/javascript" src="../../src/extras/curves.js"></script>
	<script type="text/javascript" src="../../src/renderer/webglutils.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/pointcloudrenderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendererconverter.js"></script>
	<script type="text/javascript" src="../../src/viewer/jsonfileloader.js"></script>
	<script type="text/javascript" src="../../src/viewer/mouse.js"></script>
	<script type="text/javascript" src="../../src/viewer/touch.js"></script>
	<script type="text/javascript" src="../../src/viewer/navigation.js"></script>
	<script type="text/javascript" src="../../src/viewer/softwareviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/spriteviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/viewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/pointcloudviewer.js"></script>
	<script type="text/javascript" src="../../src/three/threeconverter.js"></script>
	<script type="text/javascript" src="../../src/three/threeviewer.js"></script>
<!-- JSModeler includes end -->
	<title>Example</title>
	
	<style>
		html, body
		{
			margin : 5px;
			padding : 0px;
		}
	
		#vertexshader
		{
			display : none;
		}

		#fragmentshader
		{
			width : 100%;
			height : 500px;
			border : 1px solid #cccccc;
		}
	</style>
	
	<script type="text/javascript">
		function GetModel (index)
		{
			var model = new JSM.Model ();
			var materials = new JSM.Materials ();
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcccccc}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x00cc00}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x0000ff}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcc0000, reflection : 0.2}));
			
			var body = JSM.GenerateCuboid (1, 1, 1);
			body.SetPolygonsMaterialIndex (1);
			body.Transform (JSM.RotationZTransformation (-0.35));
			body.Transform (JSM.TranslationTransformation (new JSM.Coord (-0.2, 1.2, 0.0)));
			model.AddBody (body);

			var body2 = JSM.GenerateCuboid (0.5, 0.5, 0.5);
			body2.SetPolygonsMaterialIndex (2);
			body2.Transform (JSM.TranslationTransformation (new JSM.Coord (1.2, 0.0, -0.25)));
			model.AddBody (body2);

			var body3 = JSM.GenerateCuboid (3, 0.1, 2);
			body3.SetPolygonsMaterialIndex (3);
			body3.Transform (JSM.RotationZTransformation (-0.3));
			body3.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, -0.7, 0.5)));
			model.AddBody (body3);

			var box = JSM.GenerateCuboid (10, 10, 10);
			box.SetPolygonsMaterialIndex (0);
			JSM.MakeBodyInsideOut (box);
			box.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, 0.0, 4.5)));
			model.AddBody (box);
			
			return JSM.ConvertModelToTriangleModel (model, materials);
		}
		
		function Compile ()
		{
			var vertexShader = document.getElementById ('vertexshader').value;
			var fragmentShader = document.getElementById ('fragmentshader').value;
			var errorDiv = document.getElementById ('error');
			errorDiv.innerHTML = '';

			var canvas = document.getElementById ('example');
			var context = JSM.WebGLInitContext (canvas);
			var floatExtension = context.getExtension ('OES_texture_float');
			var shader = JSM.WebGLInitShaderProgram (context, vertexShader, fragmentShader, function (error) {
				errorDiv.innerHTML += error.replace ('\n', '<br>');
			});
			
			var vertices = new Float32Array ([-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]);
			var vertexAttribLocation = context.getAttribLocation (shader, 'aVertexPosition');
			var buffer = context.createBuffer ();
			context.bindBuffer (context.ARRAY_BUFFER, buffer);
			context.bufferData (context.ARRAY_BUFFER, vertices, context.STATIC_DRAW);
			context.vertexAttribPointer (vertexAttribLocation, 2, context.FLOAT, false, 0, 0);
			context.enableVertexAttribArray (vertexAttribLocation);
			context.bindBuffer (context.ARRAY_BUFFER, null);

			context.uniform1f (context.getUniformLocation (shader, 'uWidth'), canvas.width);
			context.uniform1f (context.getUniformLocation (shader, 'uHeight'), canvas.height);
			
			context.clear (context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
			context.drawArrays (context.TRIANGLE_FAN, 0, 4);			
		}

		function TextAreaKeyDown (event)
		{
			if (event.which == 9) {
				event.preventDefault ();
				var selectionStart = this.selectionStart;
				this.value = this.value.substring (0, this.selectionStart) + '\t' + this.value.substring (this.selectionEnd);
				this.selectionEnd = selectionStart + 1; 
			}		
		}

		function GenerateHeaderCode (model)
		{
			var triangleModel = new JSM.ConvertModelToTriangleModel (model);
			var triangleCount = triangleModel.TriangleCount ();
			var materialCount = triangleModel.MaterialCount ();
			
			var result = '';
			result += 'const int triangleCount = ' + triangleCount + ';\n';
			result += 'const int materialCount = ' + materialCount + ';\n';
			result += 'Triangle triangles[' + triangleCount + '];\n';
			result += 'Material materials[' + materialCount + '];\n';
			return result;
		}
		
		function GenerateMainCode (model, camera)
		{
			var triangleModel = new JSM.ConvertModelToTriangleModel (model);
			var result = '';
			var i, j, triangleBody, material, triangle, v0, v1, v2, currentIntersection;
			var currentIndex = 0;
			for (i = 0; i < triangleModel.BodyCount (); i++) {
				triangleBody = triangleModel.GetBody (i);
				for (j = 0; j < triangleBody.TriangleCount (); j++) {
					triangle = triangleBody.GetTriangle (j);
					v0 = triangleBody.GetVertex (triangle.v0);
					v1 = triangleBody.GetVertex (triangle.v1);
					v2 = triangleBody.GetVertex (triangle.v2);
					result += 'triangles[' + currentIndex + '].v0 = vec3 (' + v0.x + ', ' + v0.y + ', ' + v0.z + ');\n';
					result += 'triangles[' + currentIndex + '].v1 = vec3 (' + v1.x + ', ' + v1.y + ', ' + v1.z + ');\n';
					result += 'triangles[' + currentIndex + '].v2 = vec3 (' + v2.x + ', ' + v2.y + ', ' + v2.z + ');\n';
					result += 'triangles[' + currentIndex + '].material = ' + triangle.mat + ';\n';
					currentIndex += 1;
				}
			}
			for (i = 0; i < triangleModel.MaterialCount (); i++) {
				material = triangleModel.GetMaterial (i);
				result += 'materials[' + i + '].diffuse = vec3 (' + material.diffuse[0] + ', ' + material.diffuse[1] + ', ' + material.diffuse[2] + ');\n';
			}
			result += 'Camera camera;\n';
			result += 'camera.eye = vec3 (' + camera.eye.x + ', ' + camera.eye.y + ', ' + camera.eye.z + ');\n';
			result += 'camera.center = vec3 (' + camera.center.x + ', ' + camera.center.y + ', ' + camera.center.z + ');\n';
			result += 'camera.up = vec3 (' + camera.up.x + ', ' + camera.up.y + ', ' + camera.up.z + ');\n';
			return result;
		}

		function GenerateCode ()
		{
			var camera = new JSM.Camera (
				new JSM.Coord (4, 1, 2),
				new JSM.Coord (0, 0, 0),
				new JSM.Coord (0, 0, 1)
			);
			
			var body = JSM.GenerateCuboid (1, 1, 1);
			body.Transform (JSM.RotationZTransformation (-0.35));
			body.Transform (JSM.TranslationTransformation (new JSM.Coord (-0.2, 1.2, 0.0)));
			var model = new JSM.Model ();
			model.AddBody (body);
			
			var genCodeBegin = '// GENERATED CODE BEGIN\n';
			var genCodeEnd = '// GENERATED CODE END\n';
			var generatedHeaderCode = genCodeBegin + GenerateHeaderCode (model) + genCodeEnd;
			var generatedMainCode = genCodeBegin + GenerateMainCode (model, camera) + genCodeEnd;
			
			var fragmentShader = document.getElementById ('fragmentshader');
			fragmentShader.value = fragmentShader.value.replace ('[GENERATEDHEADERCODE]', generatedHeaderCode);
			fragmentShader.value = fragmentShader.value.replace ('[GENERATEDMAINCODE]', generatedMainCode);
		}
	
	    window.onload = function ()
		{
			var vertexShader = document.getElementById ('vertexshader');
			var fragmentShader = document.getElementById ('fragmentshader');
			vertexShader.onkeydown = TextAreaKeyDown;
			fragmentShader.onkeydown = TextAreaKeyDown;

			GenerateCode ();
			Compile ();			
		}
	</script>

</head>

<body>
	<div>
<textarea id="vertexshader">
precision highp float;
attribute vec2 aVertexPosition;
varying vec2 vVertexPosition;

void main (void) {
	vVertexPosition = aVertexPosition;
	gl_Position = vec4 (aVertexPosition.x, aVertexPosition.y, 0.0, 1.0);
}
</textarea>
<textarea id="fragmentshader">
precision highp float;

varying vec2 vVertexPosition;
uniform highp float uWidth;
uniform highp float uHeight;

struct Material
{
	vec3 diffuse;
};

struct Triangle
{
	vec3 v0;
	vec3 v1;
	vec3 v2;
	int material;
};

struct Camera
{
	vec3 eye;
	vec3 center;
	vec3 up;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Intersection
{
	vec3 position;
	float distance;
	int triangle;
};

vec3 CoordRotate (in vec3 coord, in vec3 axis, in float angle)
{
	vec3 normal = normalize (axis);

	float u = normal.x;
	float v = normal.y;
	float w = normal.z;

	float x = coord.x;
	float y = coord.y;
	float z = coord.z;

	float si = sin (angle);
	float co = cos (angle);

	vec3 result;
	result.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;
	result.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;
	result.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;
	return result;
}

bool RayTriangleIntersection (in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2, out Intersection intersection)
{
	vec3 rayOrigin = ray.origin;
	vec3 rayDirection = ray.direction;

	vec3 edgeDir1 = v1 - v0;
	vec3 edgeDir2 = v2 - v0;
	vec3 pVector = cross (rayDirection, edgeDir2);

	float determinant = dot (edgeDir1, pVector);
	if (determinant == 0.0) {
		return false;
	}
	
	bool isFrontFacing = determinant > 0.0;
	if (!isFrontFacing) {
		return false;
	}

	float invDeterminant = 1.0 / determinant;

	vec3 tVector = rayOrigin - v0;
	float u = dot (tVector, pVector) * invDeterminant;
	if (u < 0.0 || u > 1.0) {
		return false;
	}

	vec3 qVector = cross (tVector, edgeDir1);
	float v = dot (rayDirection, qVector) * invDeterminant;
	if (v < 0.0 || u + v > 1.0) {
		return false;
	}
 
	float distance = dot (edgeDir2, qVector) * invDeterminant;
	if (distance <= 0.0) {
		return false;
	}

	intersection.position = rayOrigin + rayDirection * distance;
	intersection.distance = distance;
	intersection.triangle = -1;
	return true;
}

Ray GetRay (in vec2 vertexPosition, in Camera camera)
{
	Ray result;
	result.origin = camera.eye;

	vec3 eyeCenterDir = normalize (camera.center - camera.eye);
	vec3 horizontalDir = normalize (cross (eyeCenterDir, camera.up));
	vec3 verticalDir = normalize (cross (horizontalDir, eyeCenterDir ));

	float cameraDistance = 1.5;
	float horizontalAngle = -atan (vertexPosition.x / cameraDistance);
	float verticalAngle = atan (vertexPosition.y / cameraDistance);
	
	result.direction = eyeCenterDir;
	result.direction = CoordRotate (result.direction, verticalDir, horizontalAngle);
	result.direction = CoordRotate (result.direction, horizontalDir, verticalAngle);

	return result;
}

[GENERATEDHEADERCODE]

bool RayModelIntersection (in Ray ray, out Intersection intersection)
{
	bool hasIntersection = false;
	intersection.distance = 1.0 / 0.0; // infinite
	for (int i = 0; i < triangleCount; i++) {
		Triangle triangle = triangles[i];
		Intersection currentIntersection;
		if (RayTriangleIntersection (ray, triangle.v0, triangle.v1, triangle.v2, currentIntersection)) {
			if (currentIntersection.distance < intersection.distance) {
				intersection.position = currentIntersection.position;
				intersection.distance = currentIntersection.distance;
				intersection.triangle = i;
			}
			hasIntersection = true;
		}
	}
	return hasIntersection;
}

vec4 PhongShading (in Intersection intersection)
{

	return vec4 (1.0, 0.0, 0.0, 1.0);
}

void main (void) {

[GENERATEDMAINCODE]
	
	Ray ray = GetRay (vVertexPosition, camera);
	Intersection intersection;
	bool hasIntersection = RayModelIntersection (ray, intersection);
	if (hasIntersection) {
		gl_FragColor = PhongShading (intersection);
	} else {
		gl_FragColor = vec4 (0.0, 0.0, 0.0, 1.0);
	}
}
</textarea>
	</div>
	<div>
		<input type="button" value="render" onclick="Compile ();"></input>
	</div>
	<div id="error"></div>
	<canvas id="example" width="256" height="256"></canvas>
</body>

</html>
