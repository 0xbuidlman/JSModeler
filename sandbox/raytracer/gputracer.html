<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>

	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="../build/three.min.js"></script>
<!-- JSModeler includes start -->
	<script type="text/javascript" src="../../src/core/jsm.js"></script>
	<script type="text/javascript" src="../../src/core/timer.js"></script>
	<script type="text/javascript" src="../../src/core/algorithm.js"></script>
	<script type="text/javascript" src="../../src/core/async.js"></script>
	<script type="text/javascript" src="../../src/core/check.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord.js"></script>
	<script type="text/javascript" src="../../src/geometry/determinant.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/matrix.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystem.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystemutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sector.js"></script>
	<script type="text/javascript" src="../../src/geometry/sectorutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/line.js"></script>
	<script type="text/javascript" src="../../src/geometry/lineutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/box.js"></script>
	<script type="text/javascript" src="../../src/geometry/boxutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sphere.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformation.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformationutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/plane.js"></script>
	<script type="text/javascript" src="../../src/geometry/planeutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/projection.js"></script>
	<script type="text/javascript" src="../../src/geometry/convexhull.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygonutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/octree.js"></script>
	<script type="text/javascript" src="../../src/geometry/bsptree.js"></script>
	<script type="text/javascript" src="../../src/geometry/utilities.js"></script>
	<script type="text/javascript" src="../../src/geometry/ray.js"></script>
	<script type="text/javascript" src="../../src/modeler/body.js"></script>
	<script type="text/javascript" src="../../src/modeler/model.js"></script>
	<script type="text/javascript" src="../../src/modeler/color.js"></script>
	<script type="text/javascript" src="../../src/modeler/light.js"></script>
	<script type="text/javascript" src="../../src/modeler/material.js"></script>
	<script type="text/javascript" src="../../src/modeler/adjacencylist.js"></script>
	<script type="text/javascript" src="../../src/modeler/bodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/textureutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/cututils.js"></script>
	<script type="text/javascript" src="../../src/modeler/generator.js"></script>
	<script type="text/javascript" src="../../src/modeler/camera.js"></script>
	<script type="text/javascript" src="../../src/modeler/explode.js"></script>
	<script type="text/javascript" src="../../src/modeler/exporter.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebody.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglemodel.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/converter.js"></script>
	<script type="text/javascript" src="../../src/modeler/rayutils.js"></script>
	<script type="text/javascript" src="../../src/import/binaryreader.js"></script>
	<script type="text/javascript" src="../../src/import/importer.js"></script>
	<script type="text/javascript" src="../../src/import/importer3ds.js"></script>
	<script type="text/javascript" src="../../src/import/importerobj.js"></script>
	<script type="text/javascript" src="../../src/import/importerstl.js"></script>
	<script type="text/javascript" src="../../src/import/importercommon.js"></script>
	<script type="text/javascript" src="../../src/extras/solidgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/extgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/painter.js"></script>
	<script type="text/javascript" src="../../src/extras/drawing.js"></script>
	<script type="text/javascript" src="../../src/extras/subdivision.js"></script>
	<script type="text/javascript" src="../../src/extras/svgtomodel.js"></script>
	<script type="text/javascript" src="../../src/extras/csg.js"></script>
	<script type="text/javascript" src="../../src/extras/curves.js"></script>
	<script type="text/javascript" src="../../src/renderer/webglutils.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/pointcloudrenderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendererconverter.js"></script>
	<script type="text/javascript" src="../../src/viewer/jsonfileloader.js"></script>
	<script type="text/javascript" src="../../src/viewer/mouse.js"></script>
	<script type="text/javascript" src="../../src/viewer/touch.js"></script>
	<script type="text/javascript" src="../../src/viewer/navigation.js"></script>
	<script type="text/javascript" src="../../src/viewer/softwareviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/spriteviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/viewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/pointcloudviewer.js"></script>
	<script type="text/javascript" src="../../src/three/threeconverter.js"></script>
	<script type="text/javascript" src="../../src/three/threeviewer.js"></script>
<!-- JSModeler includes end -->
	<title>Example</title>
	
	<style>
		html, body
		{
			margin : 5px;
			padding : 0px;
		}
	
		#vertexshader
		{
			display : none;
		}

		#fragmentshader
		{
			width : 100%;
			height : 500px;
			border : 1px solid #cccccc;
		}
	</style>
	
	<script type="text/javascript">
		function GetModel ()
		{
			var model = new JSM.Model ();
			var body = JSM.GenerateCuboid (1, 1, 1);
			body.Transform (JSM.RotationZTransformation (-0.35));
			body.Transform (JSM.TranslationTransformation (new JSM.Coord (-0.2, 1.2, 0.0)));
			model.AddBody (body);
			var triangleModel = JSM.ConvertModelToTriangleModel (model);
			return triangleModel;

			/*
			var model = new JSM.Model ();
			var materials = new JSM.Materials ();
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcccccc}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x00cc00}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x0000ff}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcc0000, reflection : 0.2}));
			
			var body = JSM.GenerateCuboid (1, 1, 1);
			body.SetPolygonsMaterialIndex (1);
			body.Transform (JSM.RotationZTransformation (-0.35));
			body.Transform (JSM.TranslationTransformation (new JSM.Coord (-0.2, 1.2, 0.0)));
			model.AddBody (body);

			var body2 = JSM.GenerateCuboid (0.5, 0.5, 0.5);
			body2.SetPolygonsMaterialIndex (2);
			body2.Transform (JSM.TranslationTransformation (new JSM.Coord (1.2, 0.0, -0.25)));
			model.AddBody (body2);

			var body3 = JSM.GenerateCuboid (3, 0.1, 2);
			body3.SetPolygonsMaterialIndex (3);
			body3.Transform (JSM.RotationZTransformation (-0.3));
			body3.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, -0.7, 0.5)));
			model.AddBody (body3);

			var box = JSM.GenerateCuboid (10, 10, 10);
			box.SetPolygonsMaterialIndex (0);
			JSM.MakeBodyInsideOut (box);
			box.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, 0.0, 4.5)));
			model.AddBody (box);
			
			return JSM.ConvertModelToTriangleModel (model, materials);
			*/
		}
		
		function GenerateTriangleData (triangleModel)
		{
			var result = [];
			var i, j, triangleBody, triangle, v0, v1, v2;
			var currentIndex = 0;
			for (i = 0; i < triangleModel.BodyCount (); i++) {
				triangleBody = triangleModel.GetBody (i);
				for (j = 0; j < triangleBody.TriangleCount (); j++) {
					triangle = triangleBody.GetTriangle (j);
					v0 = triangleBody.GetVertex (triangle.v0);
					v1 = triangleBody.GetVertex (triangle.v1);
					v2 = triangleBody.GetVertex (triangle.v2);
					result.push (v0.x, v0.y, v0.z);
					result.push (v1.x, v1.y, v1.z);
					result.push (v2.x, v2.y, v2.z);
				}
			}
			return result;
		}
		
		WebGLGetTextureSizeForFloatArray = function (dataLength)
		{
			var neededSize = Math.ceil (Math.sqrt (dataLength / 3.0));
			return JSM.NextPowerOfTwo (neededSize);
		};
		
		WebGLCreateFloatTextureBufferFromArray = function (context, array, size)
		{
			while (array.length < size * size * 3) {
				array.push (0.0);
			}		
			var floatArray = new Float32Array (array);

			var textureBuffer = context.createTexture ();
			context.bindTexture (context.TEXTURE_2D, textureBuffer);
			context.texParameteri (context.TEXTURE_2D, context.TEXTURE_MIN_FILTER, context.NEAREST);
			context.texParameteri (context.TEXTURE_2D, context.TEXTURE_MAG_FILTER, context.NEAREST);
			context.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_S, context.CLAMP_TO_EDGE);
			context.texParameteri (context.TEXTURE_2D, context.TEXTURE_WRAP_T, context.CLAMP_TO_EDGE);
			context.texImage2D (context.TEXTURE_2D, 0, context.RGB, size, size, 0, context.RGB, context.FLOAT, floatArray);
			context.bindTexture (context.TEXTURE_2D, null);
			return textureBuffer;
		};

		function Compile ()
		{
			var vertexShader = document.getElementById ('vertexshader').value;
			var fragmentShader = document.getElementById ('fragmentshader').value;
			var errorDiv = document.getElementById ('error');
			errorDiv.innerHTML = '';

			var canvas = document.getElementById ('example');
			var context = JSM.WebGLInitContext (canvas);
			var floatExtension = context.getExtension ('OES_texture_float');
			var shader = JSM.WebGLInitShaderProgram (context, vertexShader, fragmentShader, function (error) {
				errorDiv.innerHTML += error.replace ('\n', '<br>');
			});
			
			var vertices = new Float32Array ([-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]);
			var vertexAttribLocation = context.getAttribLocation (shader, 'aVertexPosition');
			var buffer = context.createBuffer ();
			context.bindBuffer (context.ARRAY_BUFFER, buffer);
			context.bufferData (context.ARRAY_BUFFER, vertices, context.STATIC_DRAW);
			context.vertexAttribPointer (vertexAttribLocation, 2, context.FLOAT, false, 0, 0);
			context.enableVertexAttribArray (vertexAttribLocation);
			context.bindBuffer (context.ARRAY_BUFFER, null);

			context.uniform1f (context.getUniformLocation (shader, 'uWidth'), canvas.width);
			context.uniform1f (context.getUniformLocation (shader, 'uHeight'), canvas.height);
			
			var triangleModel = GetModel ();
			var triangleData = GenerateTriangleData (triangleModel);
			var textureSize = WebGLGetTextureSizeForFloatArray (triangleData.length);
			var textureBuffer = WebGLCreateFloatTextureBufferFromArray (context, triangleData, textureSize);
			
			context.activeTexture (context.TEXTURE0);
			context.bindTexture (context.TEXTURE_2D, textureBuffer);				

			context.uniform1i (context.getUniformLocation (shader, 'uTiangleTextureSampler'), 0);
			context.uniform1f (context.getUniformLocation (shader, 'uTriangleTextureSize'), textureSize);
			
			context.clear (context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
			context.drawArrays (context.TRIANGLE_FAN, 0, 4);			
		}

		function TextAreaKeyDown (event)
		{
			if (event.which == 9) {
				event.preventDefault ();
				var selectionStart = this.selectionStart;
				this.value = this.value.substring (0, this.selectionStart) + '\t' + this.value.substring (this.selectionEnd);
				this.selectionEnd = selectionStart + 1; 
			}		
		}
		
	    window.onload = function ()
		{
			var vertexShader = document.getElementById ('vertexshader');
			var fragmentShader = document.getElementById ('fragmentshader');
			vertexShader.onkeydown = TextAreaKeyDown;
			fragmentShader.onkeydown = TextAreaKeyDown;

			Compile ();			
		}
	</script>

</head>

<body>
	<div>
<textarea id="vertexshader">
precision highp float;
attribute vec2 aVertexPosition;
varying vec2 vVertexPosition;

void main (void) {
	vVertexPosition = aVertexPosition;
	gl_Position = vec4 (aVertexPosition.x, aVertexPosition.y, 0.0, 1.0);
}
</textarea>
<textarea id="fragmentshader">
precision highp float;

varying vec2 vVertexPosition;
uniform highp float uWidth;
uniform highp float uHeight;

#define TRIANGLE_COUNT 12
uniform sampler2D uTiangleTextureSampler;
uniform highp float uTriangleTextureSize;

struct Material
{
	vec3 diffuse;
};

struct Triangle
{
	vec3 v0;
	vec3 v1;
	vec3 v2;
};

struct Camera
{
	vec3 eye;
	vec3 center;
	vec3 up;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Intersection
{
	vec3 position;
	float distance;
	int triangle;
};

vec3 GetFloatVector (in sampler2D sampler, in float textureWidth, in float textureHeight, in int index)
{
	float pixelSizeX = 1.0 / textureWidth;
	float pixelSizeY = 1.0 / textureHeight;
	float xCoordinate = mod (float (index), textureWidth) * pixelSizeX + pixelSizeX * 0.5;
	float yCoordinate = floor (float (index) / textureWidth) * pixelSizeY + pixelSizeY * 0.5;
	vec4 textureColor = texture2D (sampler, vec2 (xCoordinate, yCoordinate));
	return textureColor.xyz;
}

Triangle GetTriangle (in sampler2D sampler, in float textureWidth, in float textureHeight, in int index)
{
	Triangle triangle;
	triangle.v0 = GetFloatVector (sampler, textureWidth, textureHeight, index * 3);
	triangle.v1 = GetFloatVector (sampler, textureWidth, textureHeight, index * 3 + 1);
	triangle.v2 = GetFloatVector (sampler, textureWidth, textureHeight, index * 3 + 2);
	return triangle;
}

vec3 CoordRotate (in vec3 coord, in vec3 axis, in float angle)
{
	vec3 normal = normalize (axis);

	float u = normal.x;
	float v = normal.y;
	float w = normal.z;

	float x = coord.x;
	float y = coord.y;
	float z = coord.z;

	float si = sin (angle);
	float co = cos (angle);

	vec3 result;
	result.x = - u * (- u * x - v * y - w * z) * (1.0 - co) + x * co + (- w * y + v * z) * si;
	result.y = - v * (- u * x - v * y - w * z) * (1.0 - co) + y * co + (w * x - u * z) * si;
	result.z = - w * (- u * x - v * y - w * z) * (1.0 - co) + z * co + (- v * x + u * y) * si;
	return result;
}

bool RayTriangleIntersection (in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2, out Intersection intersection)
{
	vec3 rayOrigin = ray.origin;
	vec3 rayDirection = ray.direction;

	vec3 edgeDir1 = v1 - v0;
	vec3 edgeDir2 = v2 - v0;
	vec3 pVector = cross (rayDirection, edgeDir2);

	float determinant = dot (edgeDir1, pVector);
	if (determinant == 0.0) {
		return false;
	}
	
	bool isFrontFacing = determinant > 0.0;
	if (!isFrontFacing) {
		return false;
	}

	float invDeterminant = 1.0 / determinant;

	vec3 tVector = rayOrigin - v0;
	float u = dot (tVector, pVector) * invDeterminant;
	if (u < 0.0 || u > 1.0) {
		return false;
	}

	vec3 qVector = cross (tVector, edgeDir1);
	float v = dot (rayDirection, qVector) * invDeterminant;
	if (v < 0.0 || u + v > 1.0) {
		return false;
	}
 
	float distance = dot (edgeDir2, qVector) * invDeterminant;
	if (distance <= 0.0) {
		return false;
	}

	intersection.position = rayOrigin + rayDirection * distance;
	intersection.distance = distance;
	intersection.triangle = -1;
	return true;
}

bool RayModelIntersection (in Ray ray, out Intersection intersection)
{
	bool hasIntersection = false;
	intersection.distance = 1.0 / 0.0; // infinite
	for (int i = 0; i < TRIANGLE_COUNT; i++) {
		Triangle triangle = GetTriangle (uTiangleTextureSampler, uTriangleTextureSize, uTriangleTextureSize, i);
		Intersection currentIntersection;
		if (RayTriangleIntersection (ray, triangle.v0, triangle.v1, triangle.v2, currentIntersection)) {
			if (currentIntersection.distance < intersection.distance) {
				intersection.position = currentIntersection.position;
				intersection.distance = currentIntersection.distance;
				intersection.triangle = i;
			}
			hasIntersection = true;
		}
	}
	return hasIntersection;
}

Ray GetRay (in vec2 vertexPosition, in Camera camera)
{
	Ray result;
	result.origin = camera.eye;

	vec3 eyeCenterDir = normalize (camera.center - camera.eye);
	vec3 horizontalDir = normalize (cross (eyeCenterDir, camera.up));
	vec3 verticalDir = normalize (cross (horizontalDir, eyeCenterDir ));

	float cameraDistance = 1.5;
	float horizontalAngle = -atan (vertexPosition.x / cameraDistance);
	float verticalAngle = atan (vertexPosition.y / cameraDistance);
	
	result.direction = eyeCenterDir;
	result.direction = CoordRotate (result.direction, verticalDir, horizontalAngle);
	result.direction = CoordRotate (result.direction, horizontalDir, verticalAngle);

	return result;
}

void main (void) {
	Camera camera;
	camera.eye = vec3 (4, 1, 2);
	camera.center = vec3 (0, 0, 0);
	camera.up = vec3 (0, 0, 1);
	
	Ray ray = GetRay (vVertexPosition, camera);
	Intersection intersection;
	bool hasIntersection = RayModelIntersection (ray, intersection);
	if (hasIntersection) {
		gl_FragColor = vec4 (1.0, 0.0, 0.0, 1.0);
	} else {
		gl_FragColor = vec4 (0.0, 0.0, 0.0, 1.0);
	}	
}
</textarea>
	</div>
	<div>
		<input type="button" value="render" onclick="Compile ();"></input>
	</div>
	<div id="error"></div>
	<canvas id="example" width="256" height="256"></canvas>
</body>

</html>
