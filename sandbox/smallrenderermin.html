<!doctype html>
<html>
	<head>
		<title>JS1k, [COMPO] demo submission [ID]</title>
		<meta charset="utf-8" />
    <style>
      html, body { margin: 0; padding: 0; border: 0; }
      #c { display: block; } /* kill scrollbars from hell */
    </style>
	</head>
	<body>
		<canvas id="c"></canvas>
		<script>
			var a = document.getElementsByTagName('canvas')[0];
			var b = document.body;
      var d = function(e){ return function(){ e.parentNode.removeChild(e); }; }(a);
      // unprefix some popular vendor prefixed things (but stick to their original name)
      var AudioContext =
        window.AudioContext ||
        window.webkitAudioContext;
      var requestAnimationFrame =
        window.requestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(f){ setTimeout(f, 1000/30); };

      // fix bug in safari: http://qfox.nl/weblog/218
      document.body.clientWidth;
      // auto resize (original) canvas. call `onresize(w,h) to limit the size of the canvas
      (window.onorientationchange = window.onresize = function(a){
        var mw = Infinity;
        var mh = Infinity;
        var min = Math.min;

        return function(w,h){
          if (arguments.length === 2) {
            mw = w;
            mh = h;
          }
          a.style.width = (a.width = min(mw, innerWidth)) + 'px';
          a.style.height = (a.height = min(mh, innerHeight)) + 'px';
        };
      }(a))();

      var c = a.getContext('2d');
		</script>
		<script>
// start of submission //
			function R ()
			{
				function Product (a, b, cross)
				{
					var x1 = a[0], y1 = a[1], z1 = a[2], x2 = b[0], y2 = b[1], z2 = b[2];
					return cross ?
						[y1 * z2 - z1 * y2, z1 * x2 - x1 * z2, x1 * y2 - y1 * x2] :
						x1 * x2 + y1 * y2 + z1 * z2
				};

				function Sub (a, b)
				{
					return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
				};

				function GetVertex (i)
				{
					var val = 1.61803,
						table = [0, 1, -1, val, -val],
						ind = 3 * (parseInt (polygons[i], 16));
					return [table[vertices[ind]], table[vertices[ind + 1]], table[vertices[ind + 2]]];
				}

				var w = a.width,
					h = a.height,		
					ex = e[0],
					ey = e[1],
					ez = e[2],
					size = [w, h, 1],
					eDist = Math.sqrt (ex * ex + ey * ey + ez * ez),
					d = [ex / eDist, ey / eDist, ez / eDist],
					v = [-d[1], d[0], 0],
					u = Product (d, v, 1),
					half = 2 / (w / h),
					de = Product (d, e),
					matrix = [
						v[0] * half, 2 * u[0], d[0], -d[0],
						v[1] * half, 2 * u[1], d[1], -d[1],
						v[2] * half, 2 * u[2], d[2], -d[2],
						-Product (v, e) * h, 2 * -Product (u, e), -de + 2, de
					],
					vertices = '013014023024130140230240301302401402',
					polygons = '02804606a0840a213b1491641931b62582752a735737b3954896ba5987ab',
					rot = 0.005,
					i, j, coord, projected, l;
				
				c.clearRect (0, 0, w, h);
				c.fillStyle = '#38b';
				for (i = 0; i < polygons.length; i += 3) {
					if (Product (Product (Sub (GetVertex (i), GetVertex (i + 1)), Sub (GetVertex (i + 2), GetVertex (i + 1)), 1), Sub (e, GetVertex (i))) < 0) {
						c.beginPath ();
						j = 4;
						while (j--) {
							coord = GetVertex(i + j % 3);
							projected = [0, 0, 0, 0];
							for (k in matrix) {
								projected[~~(k/4)] += (k%4 < 3 ? coord[k%4] : 1) * matrix[~~(k/4) + k%4 * 4];
							}
							for (l in projected) {
								projected[l] = (projected[l] / projected[3] / 2 + 0.5) * size[l];
							}
							c.lineTo (projected[0], h - projected[1]);
						}
						c.fill ();
						c.stroke ();
					}
				}			
				e = [ex - ey * rot, ex * rot + ey, ez];
				requestAnimationFrame (R);
			}

			var e = [-4, 2, 2];
			R ();
// end of submission //
		</script>
	</body>
</html>
