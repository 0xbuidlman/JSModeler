<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>

	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="../build/three.min.js"></script>
<!-- JSModeler includes start -->
	<script type="text/javascript" src="../../src/core/jsm.js"></script>
	<script type="text/javascript" src="../../src/core/timer.js"></script>
	<script type="text/javascript" src="../../src/core/algorithm.js"></script>
	<script type="text/javascript" src="../../src/core/async.js"></script>
	<script type="text/javascript" src="../../src/core/check.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord.js"></script>
	<script type="text/javascript" src="../../src/geometry/determinant.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/matrix.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystem.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystemutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sector.js"></script>
	<script type="text/javascript" src="../../src/geometry/sectorutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/line.js"></script>
	<script type="text/javascript" src="../../src/geometry/lineutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/box.js"></script>
	<script type="text/javascript" src="../../src/geometry/boxutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sphere.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformation.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformationutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/plane.js"></script>
	<script type="text/javascript" src="../../src/geometry/planeutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/projection.js"></script>
	<script type="text/javascript" src="../../src/geometry/convexhull.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygonutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/octree.js"></script>
	<script type="text/javascript" src="../../src/geometry/bsptree.js"></script>
	<script type="text/javascript" src="../../src/geometry/utilities.js"></script>
	<script type="text/javascript" src="../../src/geometry/ray.js"></script>
	<script type="text/javascript" src="../../src/modeler/body.js"></script>
	<script type="text/javascript" src="../../src/modeler/model.js"></script>
	<script type="text/javascript" src="../../src/modeler/color.js"></script>
	<script type="text/javascript" src="../../src/modeler/light.js"></script>
	<script type="text/javascript" src="../../src/modeler/material.js"></script>
	<script type="text/javascript" src="../../src/modeler/adjacencylist.js"></script>
	<script type="text/javascript" src="../../src/modeler/bodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/textureutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/cututils.js"></script>
	<script type="text/javascript" src="../../src/modeler/generator.js"></script>
	<script type="text/javascript" src="../../src/modeler/camera.js"></script>
	<script type="text/javascript" src="../../src/modeler/explode.js"></script>
	<script type="text/javascript" src="../../src/modeler/exporter.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebody.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglemodel.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/converter.js"></script>
	<script type="text/javascript" src="../../src/modeler/rayutils.js"></script>
	<script type="text/javascript" src="../../src/import/binaryreader.js"></script>
	<script type="text/javascript" src="../../src/import/importer.js"></script>
	<script type="text/javascript" src="../../src/import/importer3ds.js"></script>
	<script type="text/javascript" src="../../src/import/importerobj.js"></script>
	<script type="text/javascript" src="../../src/import/importerstl.js"></script>
	<script type="text/javascript" src="../../src/import/importercommon.js"></script>
	<script type="text/javascript" src="../../src/extras/solidgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/extgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/painter.js"></script>
	<script type="text/javascript" src="../../src/extras/drawing.js"></script>
	<script type="text/javascript" src="../../src/extras/subdivision.js"></script>
	<script type="text/javascript" src="../../src/extras/svgtomodel.js"></script>
	<script type="text/javascript" src="../../src/extras/csg.js"></script>
	<script type="text/javascript" src="../../src/extras/curves.js"></script>
	<script type="text/javascript" src="../../src/renderer/webglutils.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/pointcloudrenderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendererconverter.js"></script>
	<script type="text/javascript" src="../../src/viewer/jsonfileloader.js"></script>
	<script type="text/javascript" src="../../src/viewer/mouse.js"></script>
	<script type="text/javascript" src="../../src/viewer/touch.js"></script>
	<script type="text/javascript" src="../../src/viewer/navigation.js"></script>
	<script type="text/javascript" src="../../src/viewer/softwareviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/spriteviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/viewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/pointcloudviewer.js"></script>
	<script type="text/javascript" src="../../src/three/threeconverter.js"></script>
	<script type="text/javascript" src="../../src/three/threeviewer.js"></script>
<!-- JSModeler includes end -->
	<script type="text/javascript" src="gputracer.js"></script>
	<title>Example</title>
	
	<style>
		html, body
		{
			margin : 5px;
			padding : 0px;
		}

		#fragmentshader
		{
			width : 100%;
			height : 500px;
			border : 1px solid #cccccc;
		}
	</style>
	
	<script type="text/javascript">
		function GetModel ()
		{
			var model = new JSM.Model ();
			var materials = new JSM.Materials ();
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcccccc}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x00cc00}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0x0000ff}));
			materials.AddMaterial (new JSM.Material ({ambient : 0x000000, diffuse : 0xcc0000, reflection : 0.2}));
			
			var body = JSM.GenerateCuboid (1, 1, 1);
			body.SetPolygonsMaterialIndex (1);
			body.Transform (JSM.RotationZTransformation (-0.35));
			body.Transform (JSM.TranslationTransformation (new JSM.Coord (-0.2, 1.2, 0.0)));
			model.AddBody (body);

			var body2 = JSM.GenerateCuboid (0.5, 0.5, 0.5);
			body2.SetPolygonsMaterialIndex (2);
			body2.Transform (JSM.TranslationTransformation (new JSM.Coord (1.2, 0.0, -0.25)));
			model.AddBody (body2);

			var body3 = JSM.GenerateCuboid (3, 0.1, 2);
			body3.SetPolygonsMaterialIndex (3);
			body3.Transform (JSM.RotationZTransformation (-0.3));
			body3.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, -0.7, 0.5)));
			model.AddBody (body3);

			var box = JSM.GenerateCuboid (10, 10, 10);
			box.SetPolygonsMaterialIndex (0);
			JSM.MakeBodyInsideOut (box);
			box.Transform (JSM.TranslationTransformation (new JSM.Coord (0.0, 0.0, 4.5)));
			model.AddBody (box);
			
			return JSM.ConvertModelToTriangleModel (model, materials);
		}
		
		var gpuTracer = null;
		
		function Compile ()
		{
			var triangleModel = GetModel ();

			var errorDiv = document.getElementById ('error');
			errorDiv.innerHTML = '';

			var fragmentShader = document.getElementById ('fragmentshader').value;

			gpuTracer = new GPUTracer ();
			var canvas = document.getElementById ('example');
			var timer = new JSM.Timer ();
			timer.Start ();
			gpuTracer.Init (canvas, triangleModel, fragmentShader, function (error) {
				errorDiv.innerHTML += error.replace ('\n', '<br>');
			});
			timer.Stop ();
			errorDiv.innerHTML += 'Compile time: ' + timer.Result () + '<br>';
			
			gpuTracer.Start ();
		}

		function TextAreaKeyDown (event)
		{
			if (event.which == 9) {
				event.preventDefault ();
				var selectionStart = this.selectionStart;
				this.value = this.value.substring (0, this.selectionStart) + '\t' + this.value.substring (this.selectionEnd);
				this.selectionEnd = selectionStart + 1; 
			}		
		}
		
	    window.onload = function ()
		{
			var fragmentShader = document.getElementById ('fragmentshader');
			fragmentShader.onkeydown = TextAreaKeyDown;

			Compile ();			
		}
	</script>

</head>

<body>
	<div>
<textarea id="fragmentshader">
precision highp float;

varying vec2 vVertexPosition;
uniform float uSize;

#define EPS 0.00005
#define PI 3.1415926535897932384626433832795
#define INF 1.0 / 0.0

#define TRIANGLE_COUNT [TRIANGLE_COUNT]
uniform sampler2D uOriginalTextureSampler;
uniform sampler2D uTiangleTextureSampler;
uniform float uTriangleTextureSize;
uniform sampler2D uMaterialTextureSampler;
uniform float uMaterialTextureSize;

uniform vec3 uCameraData[3];
uniform vec3 uLightPosition;
uniform float uIteration;

struct Triangle
{
	vec3 v0;
	vec3 v1;
	vec3 v2;
	vec3 n0;
	vec3 n1;
	vec3 n2;
	int mat;
};

struct Material
{
	vec3 ambient;
	vec3 diffuse;
	float reflection;
};

struct Camera
{
	vec3 eye;
	vec3 center;
	vec3 up;
};

struct Ray
{
	vec3 origin;
	vec3 direction;
	float length;
};

struct Intersection
{
	vec3 position;
	float distance;
	vec3 normal;
	int triangle;
};

float Random (float seed)
{
    return fract (sin (dot (vec2 (seed, seed), vec2 (12.9898,78.233))) * 43758.5453 + seed);
}

vec3 CalculateTriangleNormal (in Triangle triangle)
{
	vec3 v = triangle.v1 - triangle.v0;
	vec3 w = triangle.v2 - triangle.v0;
	
	vec3 normal;
	normal.x = (v.y * w.z - v.z * w.y);
	normal.y = (v.z * w.x - v.x * w.z);
	normal.z = (v.x * w.y - v.y * w.x);

	return normalize (normal);
}

float GetTriangleArea (in float a, in float b, in float c)
{
	float s = (a + b + c) / 2.0;
	float areaSquare = s * (s - a) * (s - b) * (s - c);
	if (areaSquare < EPS) {
		return 0.0;
	}
	return sqrt (areaSquare);
}

vec3 BarycentricInterpolation (in vec3 vertex0, in vec3 vertex1, in vec3 vertex2, in vec3 value0, in vec3 value1, in vec3 value2, in vec3 position)
{
	float edge0 = length (vertex0 - vertex1);
	float edge1 = length (vertex1 - vertex2);
	float edge2 = length (vertex2 - vertex0);
	
	float distance0 = length (vertex0 - position);
	float distance1 = length (vertex1 - position);
	float distance2 = length (vertex2 - position);
	
	float area = GetTriangleArea (edge0, edge1, edge2);
	if (area == 0.0) {
		return value0;
	}
	
	float area0 = GetTriangleArea (edge0, distance0, distance1);
	float area1 = GetTriangleArea (edge1, distance1, distance2);
	float area2 = GetTriangleArea (edge2, distance0, distance2);
	
	vec3 interpolated0 = value0 * area1;
	vec3 interpolated1 = value1 * area2;
	vec3 interpolated2 = value2 * area0;
	vec3 interpolated = interpolated0 + interpolated1 + interpolated2;
	return interpolated / area;
}

vec3 GetTriangleNormal (in Triangle triangle, in vec3 normalPosition)
{
	vec3 normal = BarycentricInterpolation (
		triangle.v0, triangle.v1, triangle.v2,
		triangle.n0, triangle.n1, triangle.n2,
		normalPosition);
	return normalize (normal);
}

bool RayTriangleIntersection (in Ray ray, in vec3 v0, in vec3 v1, in vec3 v2, bool frontFacing, out Intersection intersection)
{
	vec3 rayOrigin = ray.origin;
	vec3 rayDirection = ray.direction;

	vec3 edgeDir1 = v1 - v0;
	vec3 edgeDir2 = v2 - v0;
	vec3 pVector = cross (rayDirection, edgeDir2);

	float determinant = dot (edgeDir1, pVector);
	if (abs (determinant) < EPS) {
		return false;
	}
	
	bool isFrontFacing = determinant > 0.0;
	if (frontFacing && !isFrontFacing) {
		return false;
	}

	float invDeterminant = 1.0 / determinant;

	vec3 tVector = rayOrigin - v0;
	float u = dot (tVector, pVector) * invDeterminant;
	if (u < -EPS || u > 1.0 - EPS) {
		return false;
	}

	vec3 qVector = cross (tVector, edgeDir1);
	float v = dot (rayDirection, qVector) * invDeterminant;
	if (v < -EPS || u + v > 1.0 - EPS) {
		return false;
	}
 
	float distance = dot (edgeDir2, qVector) * invDeterminant;
	if (distance < EPS) {
		return false;
	}

	if (ray.length < distance) {
		return false;
	}	
	
	intersection.position = rayOrigin + rayDirection * distance;
	intersection.distance = distance;
	intersection.triangle = -1;
	return true;
}

vec3 GetReflectedDirection (in vec3 direction, in vec3 normal)
{
	float dotProduct = dot (normal, direction);
	vec3 reflected = direction - normal * 2.0 * dotProduct;
	return normalize (reflected);
}
	
vec3 GetFloatVector (in sampler2D sampler, in float textureSize, in int index)
{
	float pixelSize = 1.0 / textureSize;
	float xCoordinate = mod (float (index), textureSize) * pixelSize + pixelSize * 0.5;
	float yCoordinate = floor (float (index) / textureSize) * pixelSize + pixelSize * 0.5;
	vec4 textureColor = texture2D (sampler, vec2 (xCoordinate, yCoordinate));
	return textureColor.xyz;
}

Triangle GetTriangle (in int index)
{
	Triangle triangle;
	triangle.v0 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 0);
	triangle.v1 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 1);
	triangle.v2 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 2);
	triangle.n0 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 3);
	triangle.n1 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 4);
	triangle.n2 = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 5);
	vec3 vec = GetFloatVector (uTiangleTextureSampler, uTriangleTextureSize, index * 7 + 6);
	triangle.mat = int (vec.x);
	return triangle;
}

Material GetMaterial (in int index)
{
	Material material;
	material.ambient = GetFloatVector (uMaterialTextureSampler, uMaterialTextureSize, index * 3 + 0);
	material.diffuse = GetFloatVector (uMaterialTextureSampler, uMaterialTextureSize, index * 3 + 1);
	vec3 vec = GetFloatVector (uMaterialTextureSampler, uMaterialTextureSize, index * 3 + 2);
	material.reflection = vec.x;
	return material;
}

vec3 PhongShading (in vec3 shadedPoint, in vec3 shadedPointNormal, in Material shadedMaterial)
{
	float lightAmbientIntensity = 1.0;
	float lightDiffuseIntensity = 1.0;
	
	vec3 ambientColor = shadedMaterial.ambient * lightAmbientIntensity;
	ambientColor = clamp (ambientColor, 0.0, 1.0);
	
	vec3 lightDirection = normalize (uLightPosition - shadedPoint);
	float diffuseCoeff = max (dot (lightDirection, shadedPointNormal), 0.0);
	vec3 diffuseColor = shadedMaterial.diffuse * lightDiffuseIntensity;
	diffuseColor = clamp (diffuseColor, 0.0, 1.0);
	
	vec3 color = ambientColor + diffuseColor * diffuseCoeff;
	color = clamp (color, 0.0, 1.0);
	return color;
}

bool RayModelIntersection (in Ray ray, bool frontFacing, out Intersection intersection)
{
	bool hasIntersection = false;
	intersection.distance = INF;
	for (int i = 0; i < TRIANGLE_COUNT; i++) {
		Triangle triangle = GetTriangle (i);
		Intersection currentIntersection;
		if (RayTriangleIntersection (ray, triangle.v0, triangle.v1, triangle.v2, frontFacing, currentIntersection)) {
			if (currentIntersection.distance < intersection.distance) {
				intersection.position = currentIntersection.position;
				intersection.distance = currentIntersection.distance;
				intersection.triangle = i;
			}
			hasIntersection = true;
		}
	}

	if (hasIntersection) {
		Triangle minTriangle = GetTriangle (intersection.triangle);
		intersection.normal = GetTriangleNormal (minTriangle, intersection.position);
	}
	return hasIntersection;
}

vec3 GetRandomSpherePoint (in float seed)
{
	float s = Random (seed) * PI * 2.0;
	float t = Random (seed) * 2.0 - 1.0;
	return vec3 (sin (s), cos (s), t) / sqrt (1.0 + t * t);
}

vec3 GetRandomHemispherePoint (in vec3 direction, in float seed)
{
	vec3 v = GetRandomSpherePoint (seed);
	return v * sign (dot (v, direction));
}

vec3 TraceMainRay (in Ray ray)
{
	vec3 shadedColor = vec3 (0.0, 0.0, 0.0);

#define RAYTRACE
	
#ifdef RAYTRACE
	Ray currentRay = ray;
	float currentIntensity = 1.0;
	for (int i = 0; i < 5; i++) {
		Intersection intersection;
		if (!RayModelIntersection (currentRay, true, intersection)) {
			break;
		}
		
		Triangle triangle = GetTriangle (intersection.triangle);
		Material material = GetMaterial (triangle.mat);

		Ray shadowRay;
		shadowRay.origin = intersection.position;
		shadowRay.direction = normalize (uLightPosition - intersection.position);
		shadowRay.length = length (uLightPosition - intersection.position);
		
		Intersection shadowIntersection;
		if (RayModelIntersection (shadowRay, false, shadowIntersection)) {
			break;
		}

		shadedColor += PhongShading (intersection.position, intersection.normal, material) * currentIntensity;
		currentIntensity *= material.reflection;
		if (currentIntensity == 0.0) {
			break;
		}
		
		currentRay.origin = intersection.position;
		currentRay.direction = GetReflectedDirection (currentRay.direction, intersection.normal);
	}
	return shadedColor;
#endif

	return shadedColor;
}

Ray GetRay (in vec2 vertexPosition, in Camera camera, in float iteration)
{
	vec3 eyeCenterDir = normalize (camera.center - camera.eye);
	vec3 horizontalDir = normalize (cross (eyeCenterDir, camera.up));
	vec3 verticalDir = normalize (cross (horizontalDir, eyeCenterDir ));

	float fieldOfView = PI / 3.0; // 60 degree
	float cameraDistance = 1.0 / tan (fieldOfView / 2.0);
	vec3 endPosition = camera.eye + eyeCenterDir * cameraDistance;
	
	float random = Random (iteration);
	float pixelSize = 2.0 / uSize;
	endPosition = endPosition + horizontalDir * (vertexPosition.x + random * pixelSize);
	endPosition = endPosition + verticalDir * (vertexPosition.y + random * pixelSize);
	
	Ray result;
	result.origin = camera.eye;
	result.direction = normalize (endPosition - camera.eye);
	result.length = INF;
	return result;
}

void main (void)
{
	Camera camera;
	camera.eye = uCameraData[0];
	camera.center = uCameraData[1];
	camera.up = uCameraData[2];
	
	Ray ray = GetRay (vVertexPosition, camera, uIteration);
	vec3 shadedColor = TraceMainRay (ray);
	vec2 originalPosition = (vVertexPosition + vec2 (1.0, 1.0)) / 2.0;;
	vec3 originalColor = texture2D (uOriginalTextureSampler, originalPosition).xyz;
	float weight = uIteration / (uIteration + 1.0);
	gl_FragColor = vec4 (mix (shadedColor, originalColor, weight), 1.0);
}
</textarea>
	</div>
	<div>
		<input type="button" value="render" onclick="Compile ();"></input>
	</div>
	<div id="error"></div>
	<canvas id="example" width="256" height="256"></canvas>
</body>

</html>
