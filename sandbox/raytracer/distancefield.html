<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
	 "http://www.w3.org/TR/html4/strict.dtd">

<html>

<head>

	<meta http-equiv="content-type" content="text/html;charset=utf-8">
	<script type="text/javascript" src="../build/three.min.js"></script>
<!-- JSModeler includes start -->
	<script type="text/javascript" src="../../src/core/jsm.js"></script>
	<script type="text/javascript" src="../../src/core/timer.js"></script>
	<script type="text/javascript" src="../../src/core/algorithm.js"></script>
	<script type="text/javascript" src="../../src/core/async.js"></script>
	<script type="text/javascript" src="../../src/core/check.js"></script>
	<script type="text/javascript" src="../../src/geometry/coord.js"></script>
	<script type="text/javascript" src="../../src/geometry/determinant.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils2d.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/matrix.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystem.js"></script>
	<script type="text/javascript" src="../../src/geometry/coordsystemutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sector.js"></script>
	<script type="text/javascript" src="../../src/geometry/sectorutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/line.js"></script>
	<script type="text/javascript" src="../../src/geometry/lineutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/box.js"></script>
	<script type="text/javascript" src="../../src/geometry/boxutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/sphere.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformation.js"></script>
	<script type="text/javascript" src="../../src/geometry/transformationutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/plane.js"></script>
	<script type="text/javascript" src="../../src/geometry/planeutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/projection.js"></script>
	<script type="text/javascript" src="../../src/geometry/convexhull.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygon.js"></script>
	<script type="text/javascript" src="../../src/geometry/polygonutils.js"></script>
	<script type="text/javascript" src="../../src/geometry/octree.js"></script>
	<script type="text/javascript" src="../../src/geometry/bsptree.js"></script>
	<script type="text/javascript" src="../../src/geometry/utilities.js"></script>
	<script type="text/javascript" src="../../src/geometry/ray.js"></script>
	<script type="text/javascript" src="../../src/modeler/body.js"></script>
	<script type="text/javascript" src="../../src/modeler/model.js"></script>
	<script type="text/javascript" src="../../src/modeler/color.js"></script>
	<script type="text/javascript" src="../../src/modeler/light.js"></script>
	<script type="text/javascript" src="../../src/modeler/material.js"></script>
	<script type="text/javascript" src="../../src/modeler/adjacencylist.js"></script>
	<script type="text/javascript" src="../../src/modeler/bodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/textureutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/cututils.js"></script>
	<script type="text/javascript" src="../../src/modeler/generator.js"></script>
	<script type="text/javascript" src="../../src/modeler/camera.js"></script>
	<script type="text/javascript" src="../../src/modeler/explode.js"></script>
	<script type="text/javascript" src="../../src/modeler/exporter.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebody.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglemodel.js"></script>
	<script type="text/javascript" src="../../src/modeler/trianglebodyutils.js"></script>
	<script type="text/javascript" src="../../src/modeler/converter.js"></script>
	<script type="text/javascript" src="../../src/modeler/rayutils.js"></script>
	<script type="text/javascript" src="../../src/import/binaryreader.js"></script>
	<script type="text/javascript" src="../../src/import/importer.js"></script>
	<script type="text/javascript" src="../../src/import/importer3ds.js"></script>
	<script type="text/javascript" src="../../src/import/importerobj.js"></script>
	<script type="text/javascript" src="../../src/import/importerstl.js"></script>
	<script type="text/javascript" src="../../src/import/importercommon.js"></script>
	<script type="text/javascript" src="../../src/extras/solidgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/extgenerator.js"></script>
	<script type="text/javascript" src="../../src/extras/painter.js"></script>
	<script type="text/javascript" src="../../src/extras/drawing.js"></script>
	<script type="text/javascript" src="../../src/extras/subdivision.js"></script>
	<script type="text/javascript" src="../../src/extras/svgtomodel.js"></script>
	<script type="text/javascript" src="../../src/extras/csg.js"></script>
	<script type="text/javascript" src="../../src/extras/curves.js"></script>
	<script type="text/javascript" src="../../src/renderer/webglutils.js"></script>
	<script type="text/javascript" src="../../src/renderer/renderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/pointcloudrenderer.js"></script>
	<script type="text/javascript" src="../../src/renderer/rendererconverter.js"></script>
	<script type="text/javascript" src="../../src/viewer/jsonfileloader.js"></script>
	<script type="text/javascript" src="../../src/viewer/mouse.js"></script>
	<script type="text/javascript" src="../../src/viewer/touch.js"></script>
	<script type="text/javascript" src="../../src/viewer/navigation.js"></script>
	<script type="text/javascript" src="../../src/viewer/softwareviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/spriteviewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/viewer.js"></script>
	<script type="text/javascript" src="../../src/viewer/pointcloudviewer.js"></script>
	<script type="text/javascript" src="../../src/three/threeconverter.js"></script>
	<script type="text/javascript" src="../../src/three/threeviewer.js"></script>
<!-- JSModeler includes end -->
	<script type="text/javascript" src="gputracer.js"></script>
	<title>Example</title>
	
	<style>
		html, body
		{
			margin : 5px;
			padding : 0px;
		}

		#fragmentshader
		{
			width : 100%;
			height : 500px;
			border : 1px solid #cccccc;
		}
	</style>

	<script id="fragmentshader" type="x-shader/fragment">
		precision highp float;

		varying vec2 vVertexPosition;
		uniform float uSize;

		#define EPS 0.000005
		#define BIGEPS 0.005
		#define PI 3.1415926535897932384626433832795
		#define INF 1.0 / 0.0

		uniform sampler2D uOriginalTextureSampler;
		uniform vec3 uCameraData[3];
		uniform vec3 uLightPosition;
		uniform float uLightRadius;
		uniform float uIteration;
		uniform float uShapeData1[4];
		uniform int uPreview;

		struct Camera
		{
			vec3 eye;
			vec3 center;
			vec3 up;
		};

		struct Ray
		{
			vec3 origin;
			vec3 direction;
			float length;
		};

		struct Intersection
		{
			vec3 position;
			float distance;
			vec3 color;
			bool fog;
		};

		struct Estimation
		{
			float distance;
			vec3 color;
			bool fog;
		};
		
		float Random (vec2 seed)
		{
			vec2 theSeed = seed + vec2 (uIteration, -uIteration);
			return fract (sin (dot (theSeed, vec2 (12.9898,78.233))) * 43758.5453);
		}

		vec3 Shading (in vec3 shadedPoint, in vec3 shadedPointNormal, in vec3 lightPosition, in vec3 materialDiffuseColor)
		{
			float lightDiffuseIntensity = 1.0;
			vec3 lightDirection = normalize (lightPosition - shadedPoint);
			float diffuseCoeff = max (dot (lightDirection, shadedPointNormal), 0.0);
			vec3 diffuseColor = materialDiffuseColor * lightDiffuseIntensity;
			return diffuseColor * diffuseCoeff;
		}

		float PointBoxDistance (vec3 point, vec3 origin, vec3 size)
		{
			vec3 offseted = point - origin;
			vec3 d = abs (offseted) - size;
			return min (max (d.x, max (d.y, d.z)), 0.0) + length (max (d, 0.0));
		}

		float PointSphereDistance (in vec3 point, in vec3 origin, in float radius)
		{
			vec3 offseted = point - origin;
			return length (offseted) - radius;
		}

		#define OPERATION 2
		Estimation DistanceEstimation (in vec3 point)
		{
			float planeDistance = point.z + 1.0;
			float shape1Distance = PointSphereDistance (point, vec3 (0.0, 0.0, 0.0), 1.0);
			float shape2Distance = PointBoxDistance (point, vec3 (1.0, 0.0, 0.5), vec3 (0.5, 0.5, 0.5));
			
			#if OPERATION == 1
				float operationDistance = min (shape1Distance, shape2Distance);
			#elif OPERATION == 2
				float operationDistance = max (shape1Distance, -shape2Distance);
				shape1Distance *= -1.0;
			#elif OPERATION == 3
				float operationDistance = max (shape1Distance, shape2Distance);
				//shape1Distance *= -1.0;
			#endif
			//float b = PointSphereDistance (point, vec3 (0.0, 0.0, 0.0), 1.0);
			
			Estimation result;
			result.distance = min (planeDistance, operationDistance);
			result.fog = false;
			if (planeDistance < operationDistance) {
				result.color = vec3 (0.7, 0.7, 0.7);
				result.fog = true;
			} else {
				if (shape1Distance < shape2Distance) {
					result.color = vec3 (0.8, 0.0, 0.0);
				} else {
					result.color = vec3 (0.0, 0.8, 0.0);
				}
			}
			return result;
		}

		vec3 CalculateNormal (in vec3 point)
		{
			vec3 xDir = vec3 (EPS, 0.0, 0.0);
			vec3 yDir = vec3 (0.0, EPS, 0.0);
			vec3 zDir = vec3 (0.0, 0.0, EPS);
			vec3 normal = vec3 (
				DistanceEstimation (point + xDir).distance - DistanceEstimation (point - xDir).distance,
				DistanceEstimation (point + yDir).distance - DistanceEstimation (point - yDir).distance,
				DistanceEstimation (point + zDir).distance - DistanceEstimation (point - zDir).distance
			);
			return normalize (normal);
		}

		Intersection RayModelIntersection (in Ray ray)
		{
			Intersection result;
			result.distance = INF;
			const int maxSteps = 500;
			
			vec3 shadedColor = vec3 (0.0, 0.0, 0.0);
			float distance = 0.0;
			for (int i = 0; i < maxSteps; i++) {
				vec3 currentPoint = ray.origin + ray.direction * distance;
				Estimation estimation = DistanceEstimation (currentPoint);
				distance += estimation.distance;
				if (estimation.distance < EPS) {
					result.position = currentPoint;
					result.distance = distance;
					result.color = estimation.color;
					result.fog = estimation.fog;
					break;
				}
			}
			return result;
		}

		vec3 GetReflectedDirection (in vec3 direction, in vec3 normal)
		{
			float dotProduct = dot (normal, direction);
			vec3 reflected = direction - normal * 2.0 * dotProduct;
			return normalize (reflected);
		}

		vec3 RandomDirOnSphere (in vec2 seed)
		{
			vec2 random = vec2 (Random (seed), Random (seed * 2.0)) * 6.283;
			vec3 randomDir = vec3 (sin (random.x) * vec2 (sin (random.y), cos (random.y)), cos (random.x));
			return normalize (randomDir);
		}

		vec3 RandomDirOnHemisphere (in vec3 normal, in vec2 seed)
		{
			vec3 randomDir = RandomDirOnSphere (seed);
			return (dot (randomDir, normal) < 0.0) ? -randomDir : randomDir;
		}

		vec3 TraceRay (in Ray ray, in Camera camera)
		{
			vec3 backgroundColor = vec3 (0.7, 0.7, 0.7);
			
			vec3 shadedColor = vec3 (0.0, 0.0, 0.0);
			vec3 currentColor = vec3 (1.0, 1.0, 1.0);
			Ray currentRay = ray;
			for (int i = 0; i < 3; i++) {
				Intersection intersection = RayModelIntersection (currentRay);
				if (intersection.distance == INF) {
					if (i == 0) {
						shadedColor = backgroundColor;
					}
					break;
				}

				vec3 intersectionNormal = CalculateNormal (intersection.position);
				if (uPreview == 1) {
					shadedColor = Shading (intersection.position, intersectionNormal, uLightPosition, intersection.color);
					break;
				}
			
				currentColor *= intersection.color;

				Ray lightRay;
				vec3 randomLightPoint = uLightPosition + RandomDirOnSphere (intersection.position.xy) * uLightRadius;
				vec3 lightRayDirection = normalize (randomLightPoint - intersection.position);
				lightRay.origin = intersection.position + lightRayDirection * BIGEPS;
				lightRay.direction = lightRayDirection;
				lightRay.length = length (randomLightPoint - intersection.position);
				Intersection lightIntersection = RayModelIntersection (lightRay);
				if (lightIntersection.distance == INF) {
					vec3 directLightColor = Shading (intersection.position, intersectionNormal, randomLightPoint, intersection.color);
					shadedColor += currentColor * directLightColor;
					if (i == 0 && intersection.fog) {
						float fog = 1.0 - exp (-intersection.distance * 0.1);
						shadedColor = mix (shadedColor, backgroundColor, fog);
					}
				}
				
				vec3 newDirection = RandomDirOnHemisphere (intersectionNormal, intersection.position.xy);
				currentRay.origin = intersection.position + newDirection * BIGEPS;
				currentRay.direction = newDirection;
				currentRay.length = INF;
			}
			return shadedColor;
		}

		Ray GetRay (in vec2 vertexPosition, in Camera camera, in float iteration)
		{
			vec3 eyeCenterDir = normalize (camera.center - camera.eye);
			vec3 horizontalDir = normalize (cross (eyeCenterDir, camera.up));
			vec3 verticalDir = normalize (cross (horizontalDir, eyeCenterDir ));

			float fieldOfView = PI / 3.0; // 60 degree
			float cameraDistance = 1.0 / tan (fieldOfView / 2.0);
			vec3 endPosition = camera.eye + eyeCenterDir * cameraDistance;
			
			float randomX = Random (vVertexPosition);
			float randomY = Random (-vVertexPosition);
			float pixelSize = 2.0 / uSize;
			endPosition = endPosition + horizontalDir * (vertexPosition.x + randomX * pixelSize);
			endPosition = endPosition + verticalDir * (vertexPosition.y + randomY * pixelSize);
			
			Ray result;
			result.origin = camera.eye;
			result.direction = normalize (endPosition - camera.eye);
			result.length = INF;
			return result;
		}

		void main (void)
		{
			Camera camera;
			camera.eye = uCameraData[0];
			camera.center = uCameraData[1];
			camera.up = uCameraData[2];
			
			Ray ray = GetRay (vVertexPosition, camera, uIteration);
			vec3 shadedColor = TraceRay (ray, camera);
			
			vec2 originalPosition = (vVertexPosition + vec2 (1.0, 1.0)) / 2.0;;
			vec3 originalColor = texture2D (uOriginalTextureSampler, originalPosition).xyz;
			float weight = uIteration / (uIteration + 1.0);
			gl_FragColor = vec4 (mix (shadedColor, originalColor, weight), 1.0);
		}
	</script>
	
	<script type="text/javascript">

		var gpuTracer = null;
		function Compile ()
		{
			var errorDiv = document.getElementById ('error');
			errorDiv.innerHTML = '';

			var fragmentShaderTag = document.getElementById ('fragmentshader');
			var fragmentShader = fragmentShaderTag.childNodes[0].nodeValue;

			gpuTracer = new GPUTracer ();
			var canvas = document.getElementById ('example');
			
			var camera = new JSM.Camera (
				new JSM.Coord (4, -1, 2),
				new JSM.Coord (0, 0, 0),
				new JSM.Coord (0, 0, 1)
			);
			
			var maxIteration = 256;
	
			var timer = new JSM.Timer ();
			timer.Start ();
			gpuTracer.Init (canvas, camera, maxIteration, fragmentShader, function (error) {
				errorDiv.innerHTML += error.replace ('\n', '<br>');
			});
			timer.Stop ();
			errorDiv.innerHTML += 'Compile time: ' + timer.Result () + '<br>';
			
			gpuTracer.SetUniformVector ('uLightPosition', [4.0, 2.0, 3.0]);
			gpuTracer.SetUniformFloat ('uLightRadius', 0.5);
			
			gpuTracer.SetUniformVector ('uShapeData1', [1.0, 0.0, 0.0, 0.0]);
			
			gpuTracer.Start ();
		}
		
	    window.onload = function ()
		{
			Compile ();			
		}
	</script>
	
</head>

<body>
	<div id="error"></div>
	<canvas id="example" width="512" height="512"></canvas>
</body>

</html>
